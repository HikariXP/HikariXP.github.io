<!DOCTYPE html>
<html lang="en-us">
  <head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    
    <title>My New Hugo Site</title>
    <meta name="viewport" content="width=device-width,minimum-scale=1">
    <meta name="description" content="开发者手册
官方描述-Offical Define Playables API 提供一种通过组织和评估树状结构（称为 PlayableGraph）中的数据源来创建工具、效果或其他游戏机制的方法。PlayableGraph 允许您混合、融合和修改多个数据源，并通过单个输出播放它们。
Playables API 支持动画、音频和脚本。Playables API 还提供通过脚本与动画系统和音频系统进行交互的能力。
尽管 Playables API 目前仅限于动画、音频和脚本，但它是一种通用 API，最终可供视频和其他系统使用。
Playable核心播放项需要继承IPlayable、而输出项需要继承IPlayableOutput
核心播放类：
核心输出类：
Playable是所有可播放项的基本类型，所以所有播放项变种都可以在需要的时候隐式转换为Playable
PlayableOutput也是如此，是所有可播放项输出的基本类型，定义了基本方法。
Playable 和 PlayableOutput 未暴露大量方法。但“PlayableExtensions”和“PlayableOutputExtensions”静态类提供了扩展方法。
所有非抽象可播放项都有一个公有静态方法 Create()，该方法创建相应类型的可播放项。“Create()”方法始终将 PlayableGraph 作为其第一个参数，该图拥有新创建的可播放项。某些类型的可播放项可能需要其他参数。非抽象可播放项输出还会暴露 Create() 方法。
有效的可播放项输出应链接到可播放项。如果可播放项输出未链接到可播放项，则可播放项输出不执行任何操作。要将可播放项输出链接到可播放项，请使用 PlayableOutput.SetSourcePlayable() 方法。对于该特定可播放项输出，链接的可播放项充当可播放项树的根。
流程 PlayGraph是可以播放的，通过PlayableGraph.Create(string GraphName)获取。
然后可以将一些Playable节点添加到PlayableGraph激活Graph的.Play()
ScriptPlayable : Playable一个可播放的行为，我们通过ScriptPlayable&lt;T\&gt;.Create(graphThatItShouldGoTo);来创建
随后创建一个继承于PlayableBehaviour的自定义Playable行为就行，把这个继承PlayableBehaivour的组件放入上述的T中即可。
这些都是动态的，也就是写进代码，运行的时候生成的。所以你也只能在运行的时候才能从PlayableGraphVisualizer里面看到。
保存 PlayableAsset正是为此设计，其继承于ScriptableObject，你可以通过PlayableAsset.CreatePlayable(graph,gameObject);来直接加载。
常用方法 要将两个可播放项连接在一起，请使用 PlayableGraph.Connect() 方法。请注意，某些可播放项不能有输入。
使用 PlayableGraph.Create() 静态方法来创建 PlayableGraph。
使用 PlayableGraph.Play() 方法来播放 PlayableGraph。
使用 PlayableGraph.Stop() 方法来停止播放 PlayableGraph。
使用 PlayableGraph.Evaluate() 方法来评估 PlayableGraph 在特定时间的状态。
使用 PlayableGraph.Destroy() 方法来手动销毁 PlayableGraph。此方法会自动销毁 PlayableGraph 创建的所有可播放项和可播放项输出。必须手动调用此销毁方法来销毁 PlayableGraph，否则 Unity 会发出一条错误消息。">
    <meta name="generator" content="Hugo 0.125.6">
    
    
    
    
      <meta name="robots" content="noindex, nofollow">
    
    

    
<link rel="stylesheet" href="/ananke/css/main.min.css" >



    

    
      

    

    

    
      <link rel="canonical" href="http://localhost:1313/testfolder/playable%E8%B0%83%E6%9F%A5/">
    

    <meta property="og:url" content="http://localhost:1313/testfolder/playable%E8%B0%83%E6%9F%A5/">
  <meta property="og:site_name" content="My New Hugo Site">
  <meta property="og:title" content="My New Hugo Site">
  <meta property="og:description" content="开发者手册
官方描述-Offical Define Playables API 提供一种通过组织和评估树状结构（称为 PlayableGraph）中的数据源来创建工具、效果或其他游戏机制的方法。PlayableGraph 允许您混合、融合和修改多个数据源，并通过单个输出播放它们。
Playables API 支持动画、音频和脚本。Playables API 还提供通过脚本与动画系统和音频系统进行交互的能力。
尽管 Playables API 目前仅限于动画、音频和脚本，但它是一种通用 API，最终可供视频和其他系统使用。
Playable核心播放项需要继承IPlayable、而输出项需要继承IPlayableOutput
核心播放类：
核心输出类：
Playable是所有可播放项的基本类型，所以所有播放项变种都可以在需要的时候隐式转换为Playable
PlayableOutput也是如此，是所有可播放项输出的基本类型，定义了基本方法。
Playable 和 PlayableOutput 未暴露大量方法。但“PlayableExtensions”和“PlayableOutputExtensions”静态类提供了扩展方法。
所有非抽象可播放项都有一个公有静态方法 Create()，该方法创建相应类型的可播放项。“Create()”方法始终将 PlayableGraph 作为其第一个参数，该图拥有新创建的可播放项。某些类型的可播放项可能需要其他参数。非抽象可播放项输出还会暴露 Create() 方法。
有效的可播放项输出应链接到可播放项。如果可播放项输出未链接到可播放项，则可播放项输出不执行任何操作。要将可播放项输出链接到可播放项，请使用 PlayableOutput.SetSourcePlayable() 方法。对于该特定可播放项输出，链接的可播放项充当可播放项树的根。
流程 PlayGraph是可以播放的，通过PlayableGraph.Create(string GraphName)获取。
然后可以将一些Playable节点添加到PlayableGraph激活Graph的.Play()
ScriptPlayable : Playable一个可播放的行为，我们通过ScriptPlayable&lt;T\&gt;.Create(graphThatItShouldGoTo);来创建
随后创建一个继承于PlayableBehaviour的自定义Playable行为就行，把这个继承PlayableBehaivour的组件放入上述的T中即可。
这些都是动态的，也就是写进代码，运行的时候生成的。所以你也只能在运行的时候才能从PlayableGraphVisualizer里面看到。
保存 PlayableAsset正是为此设计，其继承于ScriptableObject，你可以通过PlayableAsset.CreatePlayable(graph,gameObject);来直接加载。
常用方法 要将两个可播放项连接在一起，请使用 PlayableGraph.Connect() 方法。请注意，某些可播放项不能有输入。
使用 PlayableGraph.Create() 静态方法来创建 PlayableGraph。
使用 PlayableGraph.Play() 方法来播放 PlayableGraph。
使用 PlayableGraph.Stop() 方法来停止播放 PlayableGraph。
使用 PlayableGraph.Evaluate() 方法来评估 PlayableGraph 在特定时间的状态。
使用 PlayableGraph.Destroy() 方法来手动销毁 PlayableGraph。此方法会自动销毁 PlayableGraph 创建的所有可播放项和可播放项输出。必须手动调用此销毁方法来销毁 PlayableGraph，否则 Unity 会发出一条错误消息。">
  <meta property="og:locale" content="en-us">
  <meta property="og:type" content="article">
    <meta property="article:section" content="testfolder">

  <meta itemprop="name" content="My New Hugo Site">
  <meta itemprop="description" content="开发者手册
官方描述-Offical Define Playables API 提供一种通过组织和评估树状结构（称为 PlayableGraph）中的数据源来创建工具、效果或其他游戏机制的方法。PlayableGraph 允许您混合、融合和修改多个数据源，并通过单个输出播放它们。
Playables API 支持动画、音频和脚本。Playables API 还提供通过脚本与动画系统和音频系统进行交互的能力。
尽管 Playables API 目前仅限于动画、音频和脚本，但它是一种通用 API，最终可供视频和其他系统使用。
Playable核心播放项需要继承IPlayable、而输出项需要继承IPlayableOutput
核心播放类：
核心输出类：
Playable是所有可播放项的基本类型，所以所有播放项变种都可以在需要的时候隐式转换为Playable
PlayableOutput也是如此，是所有可播放项输出的基本类型，定义了基本方法。
Playable 和 PlayableOutput 未暴露大量方法。但“PlayableExtensions”和“PlayableOutputExtensions”静态类提供了扩展方法。
所有非抽象可播放项都有一个公有静态方法 Create()，该方法创建相应类型的可播放项。“Create()”方法始终将 PlayableGraph 作为其第一个参数，该图拥有新创建的可播放项。某些类型的可播放项可能需要其他参数。非抽象可播放项输出还会暴露 Create() 方法。
有效的可播放项输出应链接到可播放项。如果可播放项输出未链接到可播放项，则可播放项输出不执行任何操作。要将可播放项输出链接到可播放项，请使用 PlayableOutput.SetSourcePlayable() 方法。对于该特定可播放项输出，链接的可播放项充当可播放项树的根。
流程 PlayGraph是可以播放的，通过PlayableGraph.Create(string GraphName)获取。
然后可以将一些Playable节点添加到PlayableGraph激活Graph的.Play()
ScriptPlayable : Playable一个可播放的行为，我们通过ScriptPlayable&lt;T\&gt;.Create(graphThatItShouldGoTo);来创建
随后创建一个继承于PlayableBehaviour的自定义Playable行为就行，把这个继承PlayableBehaivour的组件放入上述的T中即可。
这些都是动态的，也就是写进代码，运行的时候生成的。所以你也只能在运行的时候才能从PlayableGraphVisualizer里面看到。
保存 PlayableAsset正是为此设计，其继承于ScriptableObject，你可以通过PlayableAsset.CreatePlayable(graph,gameObject);来直接加载。
常用方法 要将两个可播放项连接在一起，请使用 PlayableGraph.Connect() 方法。请注意，某些可播放项不能有输入。
使用 PlayableGraph.Create() 静态方法来创建 PlayableGraph。
使用 PlayableGraph.Play() 方法来播放 PlayableGraph。
使用 PlayableGraph.Stop() 方法来停止播放 PlayableGraph。
使用 PlayableGraph.Evaluate() 方法来评估 PlayableGraph 在特定时间的状态。
使用 PlayableGraph.Destroy() 方法来手动销毁 PlayableGraph。此方法会自动销毁 PlayableGraph 创建的所有可播放项和可播放项输出。必须手动调用此销毁方法来销毁 PlayableGraph，否则 Unity 会发出一条错误消息。">
  <meta itemprop="wordCount" content="150"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="">
<meta name="twitter:description" content="开发者手册
官方描述-Offical Define Playables API 提供一种通过组织和评估树状结构（称为 PlayableGraph）中的数据源来创建工具、效果或其他游戏机制的方法。PlayableGraph 允许您混合、融合和修改多个数据源，并通过单个输出播放它们。
Playables API 支持动画、音频和脚本。Playables API 还提供通过脚本与动画系统和音频系统进行交互的能力。
尽管 Playables API 目前仅限于动画、音频和脚本，但它是一种通用 API，最终可供视频和其他系统使用。
Playable核心播放项需要继承IPlayable、而输出项需要继承IPlayableOutput
核心播放类：
核心输出类：
Playable是所有可播放项的基本类型，所以所有播放项变种都可以在需要的时候隐式转换为Playable
PlayableOutput也是如此，是所有可播放项输出的基本类型，定义了基本方法。
Playable 和 PlayableOutput 未暴露大量方法。但“PlayableExtensions”和“PlayableOutputExtensions”静态类提供了扩展方法。
所有非抽象可播放项都有一个公有静态方法 Create()，该方法创建相应类型的可播放项。“Create()”方法始终将 PlayableGraph 作为其第一个参数，该图拥有新创建的可播放项。某些类型的可播放项可能需要其他参数。非抽象可播放项输出还会暴露 Create() 方法。
有效的可播放项输出应链接到可播放项。如果可播放项输出未链接到可播放项，则可播放项输出不执行任何操作。要将可播放项输出链接到可播放项，请使用 PlayableOutput.SetSourcePlayable() 方法。对于该特定可播放项输出，链接的可播放项充当可播放项树的根。
流程 PlayGraph是可以播放的，通过PlayableGraph.Create(string GraphName)获取。
然后可以将一些Playable节点添加到PlayableGraph激活Graph的.Play()
ScriptPlayable : Playable一个可播放的行为，我们通过ScriptPlayable&lt;T\&gt;.Create(graphThatItShouldGoTo);来创建
随后创建一个继承于PlayableBehaviour的自定义Playable行为就行，把这个继承PlayableBehaivour的组件放入上述的T中即可。
这些都是动态的，也就是写进代码，运行的时候生成的。所以你也只能在运行的时候才能从PlayableGraphVisualizer里面看到。
保存 PlayableAsset正是为此设计，其继承于ScriptableObject，你可以通过PlayableAsset.CreatePlayable(graph,gameObject);来直接加载。
常用方法 要将两个可播放项连接在一起，请使用 PlayableGraph.Connect() 方法。请注意，某些可播放项不能有输入。
使用 PlayableGraph.Create() 静态方法来创建 PlayableGraph。
使用 PlayableGraph.Play() 方法来播放 PlayableGraph。
使用 PlayableGraph.Stop() 方法来停止播放 PlayableGraph。
使用 PlayableGraph.Evaluate() 方法来评估 PlayableGraph 在特定时间的状态。
使用 PlayableGraph.Destroy() 方法来手动销毁 PlayableGraph。此方法会自动销毁 PlayableGraph 创建的所有可播放项和可播放项输出。必须手动调用此销毁方法来销毁 PlayableGraph，否则 Unity 会发出一条错误消息。">

	
  </head>

  <body class="ma0 avenir bg-near-white">

    
   
  

  <header>
    <div class="bg-black">
      <nav class="pv3 ph3 ph4-ns" role="navigation">
  <div class="flex-l justify-between items-center center">
    <a href="/" class="f3 fw2 hover-white no-underline white-90 dib">
      
        My New Hugo Site
      
    </a>
    <div class="flex-l items-center">
      

      
      
<div class="ananke-socials">
  
</div>

    </div>
  </div>
</nav>

    </div>
  </header>



    <main class="pb7" role="main">
      
  
  <article class="flex-l flex-wrap justify-between mw8 center ph3">
    <header class="mt4 w-100">
      <aside class="instapaper_ignoref b helvetica tracked ttu">
          
        TestFolders
      </aside>
      










  <div id="sharing" class="mt3 ananke-socials">
    
  </div>


      <h1 class="f1 athelas mt3 mb1"></h1>
      
      
      

      
      
    </header>
    <div class="nested-copy-line-height lh-copy serif f4 nested-links mid-gray pr4-l w-two-thirds-l"><p><a href="https://docs.unity.cn/cn/2020.3/Manual/Playables.html">开发者手册</a></p>
<h2 id="官方描述-offical-define">官方描述-Offical Define</h2>
<p>Playables API 提供一种通过组织和评估树状结构（称为 PlayableGraph）中的数据源来创建工具、效果或其他游戏机制的方法。PlayableGraph 允许您混合、融合和修改多个数据源，并通过单个输出播放它们。</p>
<p>Playables API 支持动画、音频和脚本。Playables API 还提供通过脚本与<a href="https://docs.unity3d.com/cn/current/Manual/AnimationSection.html">动画系统</a>和音频系统进行交互的能力。</p>
<p>尽管 Playables API 目前仅限于<code>动画</code>、<code>音频</code>和<code>脚本</code>，但它是一种通用 API，最终可供视频和其他系统使用。</p>
<p>Playable核心播放项需要继承<code>IPlayable</code>、而输出项需要继承<code>IPlayableOutput</code></p>
<p>核心播放类：</p>
<p><img src="LocalFigureBed/PlayablesGraph1.png" alt=""></p>
<p>核心输出类：</p>
<p><img src="LocalFigureBed/PlayablesGraph2.png" alt=""></p>
<p><code>Playable</code>是所有可播放项的基本类型，所以所有播放项变种都可以在需要的时候隐式转换为<code>Playable</code></p>
<p><code>PlayableOutput</code>也是如此，是所有可播放项输出的基本类型，定义了基本方法。</p>
<p><em><code>Playable</code> 和 <code>PlayableOutput</code> 未暴露大量方法。但“PlayableExtensions”和“PlayableOutputExtensions”静态类提供了扩展方法。</em></p>
<p>所有非抽象可播放项都有一个公有静态方法 <code>Create()</code>，该方法创建相应类型的可播放项。“Create()”方法始终将 PlayableGraph 作为其第一个参数，该图拥有新创建的可播放项。某些类型的可播放项可能需要其他参数。非抽象可播放项输出还会暴露 <code>Create()</code> 方法。</p>
<p>有效的可播放项输出应链接到可播放项。如果可播放项输出未链接到可播放项，则可播放项输出不执行任何操作。要将可播放项输出链接到可播放项，请使用 <code>PlayableOutput.SetSourcePlayable()</code> 方法。对于该特定可播放项输出，链接的可播放项充当可播放项树的根。</p>
<h3 id="流程">流程</h3>
<p><code>PlayGraph</code>是可以播放的，通过<code>PlayableGraph.Create(string GraphName)</code>获取。</p>
<p>然后可以将一些<code>Playable</code>节点添加到<code>PlayableGraph</code>激活Graph的<code>.Play()</code></p>
<p><code>ScriptPlayable : Playable</code>一个可播放的行为，我们通过<code>ScriptPlayable&lt;T\&gt;.Create(graphThatItShouldGoTo);</code>来创建</p>
<p>随后创建一个继承于<code>PlayableBehaviour</code>的自定义Playable行为就行，把这个继承<code>PlayableBehaivour</code>的组件放入上述的T中即可。</p>
<p>这些都是动态的，也就是写进代码，运行的时候生成的。所以你也只能在运行的时候才能从PlayableGraphVisualizer里面看到。</p>
<h4 id="保存">保存</h4>
<p><code>PlayableAsset</code>正是为此设计，其继承于<code>ScriptableObject</code>，你可以通过<code>PlayableAsset.CreatePlayable(graph,gameObject);</code>来直接加载。</p>
<h3 id="常用方法">常用方法</h3>
<p>要将两个可播放项连接在一起，请使用 <code>PlayableGraph.Connect()</code> 方法。请注意，某些可播放项不能有输入。</p>
<p>使用 <code>PlayableGraph.Create()</code> 静态方法来创建 PlayableGraph。</p>
<p>使用 <code>PlayableGraph.Play()</code> 方法来播放 PlayableGraph。</p>
<p>使用 <code>PlayableGraph.Stop()</code> 方法来停止播放 PlayableGraph。</p>
<p>使用 <code>PlayableGraph.Evaluate()</code> 方法来评估 PlayableGraph 在特定时间的状态。</p>
<p>使用 <code>PlayableGraph.Destroy()</code> 方法来手动销毁 PlayableGraph。此方法会自动销毁 PlayableGraph 创建的所有可播放项和可播放项输出。必须手动调用此销毁方法来销毁 PlayableGraph，否则 Unity 会发出一条错误消息。</p>
<p>Playble Core Type &amp; Playable Output Type 都继承C#的strcuts，为值类型，可以避免造成GC。</p>
<p>PlayableGraph是可以播放的，但是Playable不行。</p>
<p>Director的更新模式</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>效果</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="https://docs.unity3d.com/ScriptReference/Playables.DirectorUpdateMode.DSPClock.html">DSPClock</a></td>
<td>更新基于 DSP（数字声音处理）时钟。将此用于需要与音频同步的图形。</td>
</tr>
<tr>
<td><a href="https://docs.unity3d.com/ScriptReference/Playables.DirectorUpdateMode.GameTime.html">GameTime</a></td>
<td>更新基于 Time.time。将此用于需要在游戏过程中同步的图表，以及需要在游戏暂停时暂停的图表。</td>
</tr>
<tr>
<td><a href="https://docs.unity3d.com/ScriptReference/Playables.DirectorUpdateMode.UnscaledGameTime.html">UnscaledGameTime</a></td>
<td>更新基于 Time.unscaledTime。将此用于即使在游戏暂停时也需要更新的图表。示例：即使游戏暂停，也需要更新菜单转换。</td>
</tr>
<tr>
<td><a href="https://docs.unity3d.com/ScriptReference/Playables.DirectorUpdateMode.Manual.html">Manual</a></td>
<td>更新模式是手动的。您需要使用自己的 deltaTime 手动调用 PlayableGraph.Evaluate。这对于与游戏的其余部分完全断开的图表很有用。例如，本地化的子弹时间。</td>
</tr>
</tbody>
</table>
<h2 id="比较">比较</h2>
<p>Playable相较传统动画机更灵活</p>
<p>Playable结构更简单，可动态链接子图到主图之中。</p>
<p>Playable可以运行时修改，改逻辑结构。</p>
<p>Animator通过变量来间接控制权重，Playable可以直接控制动画权重和时间。</p>
<p>Playable在混合上具备更强灵活性。不仅可以混合两个AnimationClip，还能Clip和AnimatorController之间混合，甚至多个AnimatorController之间混合。</p>
<h2 id="结论">结论</h2>
<p>Playable提供了一套非常基础，非常底层的API供开发者使用。比较适合用来二次开发，并不适合直接使用（并不是不能用）。这带来了非常高的自由度，但也使下限比较低。</p>
<p>基于它可以开发类似于Unity自带的动画机等的工具，它有基于ScriptableObject的PlayableAsset保存方式，全程基于struct的值类型存储，避免GC。</p>
<p>使用的效果有点像是预定下来的一个类似状态机一样的模板。</p>
<p>官方基于它在推出新的工具（Animation Rigging、DataFlowGraph），而旧的工具（Mecanim，默认动画机）已经是基于Playable构建的了。存在第三方工具（Animancer）</p>
<h4 id="叉烧记录">叉烧记录</h4>
<p>文档非常稀少，案例也非常稀少。</p>
<p>使用起来更像是可以编程自定义动画的组件。</p>
<p>设计上感觉很像状态机，毕竟Animation就是基于它的。</p>
<p>对Script、Audio、Animation提供支持，但也有其他使用途径。</p>
<p>如果有个可视化编译Playable图的工具应该会很好用，感觉对热更友好。</p>
<h4 id="参考文章">参考文章</h4>
<h5 id="unityforum">UnityForum</h5>
<ul>
<li>Playable API use case : <a href="https://forum.unity.com/threads/playable-api-use-case.456338/">Click</a></li>
<li>Why does the Playables API exist, when should I use it rather than Mecanim (Animator Controllers)?：<a href="https://forum.unity.com/threads/why-does-the-playables-api-exist-when-should-i-use-it-rather-than-mecanim-animator-controllers.912857/">Click</a></li>
<li>What-about-playable-api：<a href="https://forum.unity.com/threads/what-about-playable-api.697424/?gq=playable">Click</a></li>
</ul>
<h5 id="unitydocumentation">UnityDocumentation</h5>
<p>Playables.Playable：<a href="https://docs.unity3d.com/ScriptReference/Playables.Playable.html">Click</a></p>
<h5 id="使用教程相关">使用教程相关</h5>
<ul>
<li>GameTorrahod：<a href="https://gametorrahod.com/timeline-marker-and-everything-leading-up-to-it/">Click</a></li>
</ul>
<ul class="pa0">
  
</ul>
<div class="mt6 instapaper_ignoref">
      
      
      </div>
    </div>

    <aside class="w-30-l mt6-l">




</aside>

  </article>

    </main>
    <footer class="bg-black bottom-0 w-100 pa3" role="contentinfo">
  <div class="flex justify-between">
  <a class="f4 fw4 hover-white no-underline white-70 dn dib-ns pv2 ph3" href="http://localhost:1313/" >
    &copy;  My New Hugo Site 2024 
  </a>
    <div>
<div class="ananke-socials">
  
</div>
</div>
  </div>
</footer>

  </body>
</html>
