[{"content":"从小到高中，梦想变了千千万万回：先是科学家做长生不老药，再到造高达可以去和自己喜欢的拍拖，再到只是想赚钱。变太多了还忘了部分了。\n梦想，目标，一直在变。从万能科学家到仅仅只是赚大钱，不知道这种算不算变得市侩呢。不过，这个不断改变的梦想在高二的某个晚上突然定型了，它变成了一个[可行的目标]。\n那天晚上，晚自习偷偷听歌(耳机线从衣伸出)，听到了一首\u0026quot;枪神的荣耀\u0026quot;。那是腾讯的一个TPS游戏《枪神纪》的主题曲，仿谁一目了然，但是对于当初还在玩CF的逼而言，算是很新潮很新颖的游戏，毕竟那时候是小学，连Steam都不会上。\n有幸参与过内测，在内测期间尤其上头，日夜玩。终究随着公测，以及那时候腾讯网游的运营套路，公测后一年后，在日益膨胀的数值和Pay To Win环境中渐渐放弃了。\n\u0026ldquo;为什么我不自己做一个呢？\u0026quot;，随后命运的内燃机开始燃烧。\n我必须先承认我很喜欢玩，当然指的是内测的时候。诞生这个念头之后，思考片刻认为这不是痴人说梦，随购入了一本《Java入门》，然后了解到了\u0026quot;引擎\u0026quot;这个东东，再基于我看重跨平台性，所以直接选择了Unity。又买了Unity入门。\n","date":"2024-05-12T00:00:00Z","image":"http://localhost:1313/2024/%E4%B8%80%E5%88%87%E7%9A%84%E5%BC%80%E5%A7%8B/pawel-czerwinski-8uZPynIu-rQ-unsplash_hud7e36f7e20e71be184458283bdae4646_55974_120x120_fill_q75_box_smart1.jpg","permalink":"http://localhost:1313/2024/%E4%B8%80%E5%88%87%E7%9A%84%E5%BC%80%E5%A7%8B/","title":"一切的开始"},{"content":"突然兴致而来，和同事小武聊起来博客就谈到了Hexo，随后和基友毛聊起来又谈到了Hugo。 没有经过什么详细的调查，单纯只是想找一个方便的博客框架，有不错的外观就行，将精力集中在写笔记留档上，于是随缘用上了Hugo。\n一开始甚至没留意到Stack主题(即使排的很前)，后来在配置主题上废了一整个晚上也没搞懂怎么配置，文档也没看懂，因为没有任何前端知识储备，挫败感很强。\n之后就一边遇到问题一边谷歌搜解决方案，效果不太好，其他人似乎没有遇到我那么多问题。但搜到了一篇博客 建站技术 | 使用 Hugo+Stack 简单搭建一个博客\n原谅我没有深看，因为昨天的配置失败让急于求成，但浅看发现:\u0026ldquo;好像比原装Stack要更加清晰和好用?\u0026quot;，于是便立即前往大佬的GitHub上下载。\nMantyke/Hugo-stack-theme-mod\n由于刚刚的那篇博客已经说了怎么搭建了，我也没什么前端知识，一个臭Unity开发的，就不浪费时间了再讲那部分了。甚至部署也有非常多的博客可以搜得到。\nHugo官方GithubPages部署教程\n总流程是:\n先使用Hugo创建一堆需要的基础文件 新建一个Github的仓库，并设置为Pages 将第1步生成的内容放入此仓库，并做好设置 Enjoy your blog 如果你问:\u0026ldquo;那你写这篇笔记来做什么?\u0026rdquo; 它就是我博客的 \u0026ldquo;Hello World\u0026rdquo;\n遇到的问题 倒是确实遇到了问题，比如这套主题，需要Markdown笔记具有一些前置信息去提供给主题去显示。\n+++ author = \u0026quot;CharSui\u0026quot; title = \u0026quot;部署Hugo和使用Stack改版主题\u0026quot; date = \u0026quot;2024-05-09\u0026quot; description = \u0026quot;记录第一次部署博客以及使用主题遇到的障碍\u0026quot; tags = [ \u0026quot;Hugo\u0026quot;,\u0026quot;Github-Pages\u0026quot; ] categories = [ \u0026quot;博客\u0026quot; ] series = [\u0026quot;Themes Guide\u0026quot;] aliases = [\u0026quot;migrate-from-jekyl\u0026quot;] image = \u0026quot;pawel-czerwinski-8uZPynIu-rQ-unsplash.jpg\u0026quot; +++ 第一次用的时候不知道，导致觉得很奇怪，为什么我明明放了笔记却不显示呢？明明上一个主题都可以的。\n","date":"2024-05-09T00:00:00Z","image":"http://localhost:1313/2024/%E9%83%A8%E7%BD%B2hugo%E5%92%8C%E4%BD%BF%E7%94%A8stack%E6%94%B9%E7%89%88%E4%B8%BB%E9%A2%98/pawel-czerwinski-8uZPynIu-rQ-unsplash_hud7e36f7e20e71be184458283bdae4646_55974_120x120_fill_q75_box_smart1.jpg","permalink":"http://localhost:1313/2024/%E9%83%A8%E7%BD%B2hugo%E5%92%8C%E4%BD%BF%E7%94%A8stack%E6%94%B9%E7%89%88%E4%B8%BB%E9%A2%98/","title":"部署Hugo和使用Stack改版主题"},{"content":"https://www.bilibili.com/video/BV1aJ411t7N6/\nhttps://www.bilibili.com/read/cv3260881/ GC文章翻译（第三方）\n物理内存 CPU的内存读取其实很慢，每次都会访问CPU中的Shared Cache再去内存找，也就是核心自己的内存。 台式设备和移动设备内存架构差异大：没有独显，没有显卡，CPU板上面积更小，缓存级数更少，大小更小。 所以有时候Android的报错溢出不是内存，是显存爆炸了。\n虚拟内存 内存交换（放到硬盘上的内存）移动设备的IO也很慢，移动设备的内存交换性能也有消耗，硬盘读写寿命也更少。 iOS可以进行内存压缩，但是Android没有（） iOS能把不用的程序占用的内存可以先压缩，也是存在内存里面。\n内存寻址范围 32位和64位讲的是计算器运算位数而不是MCU位数，MemoryControlUnit。\nAndroid内存管理 Android基于Linux，4K一个Page，Page是最基本的内存单位 内存杀手 - Low Memory Killer\n4K Per page 回收和分配都是以page为单位 用户态和内核态区分。内核态内存，用户态是严格不许访问的。\nAKA Lmk - low memory killer 按照软件优先度杀软件，按理来说可以把Wifi功能都给你杀了。 App原地重启都有可能。壁纸都给你杀掉。然后你手机就重启了。\n内存指标 Resident Set Size（RSS） 当前APP调用的所有内存，RSS算上所有公共库的内存，也就是你的插件也算在你的APP的PSS。\nProportional Set Size（PSS） 如果公共库有其他APP用，那就是平均分到每个APP上。\nUnique Set Size（USS） USS是只有你自己用的，纯粹只有你自己申请的。\n例子：Procrank 可以列出所有内存使用信息。 如果PSS很高，USS很低，那就很可能你是被背锅了。一般平台用的是PSS检查。\nUnity内存管理 Unity是C++引擎，底层代码完全由C++所写，每一行。 通过Wrapper提供给用户API。所以所有API都是在[.Bindings]里面放的。 用户代码仍会转换为Cpp代码(il2cpp) VM仍然存在。\n用il2cpp之后，几乎没有纯正的C#在跑。有了VM跨平台会更加方便。\n按分配方式分为 NativeMemory和ManagedMemory，在Editor和Runtime是不同的。 不同不只是说，统计数据不一样，是分配方式都不一样。\nAsset在Runtime不加载不放进内存，在Editor会全部加载。（演讲者：巨型项目见过加载一礼拜的） 2019.3推出AssetPipeline2.0，会加载基础的，后面的拓展的才会加载，详细可以自己搜搜。\nUnity内存按照管理者可以分为：引擎管理内存、用户管理内存\n引擎内存 引擎自己调用请求用的，一般开发者不需要触碰。\n用户管理内存 用户写的寄的代码就会导致很容易爆炸，确切需要关心的。\nUnity检测不到的内存：用户分配的native内存，比如用户自己写的C++插件，这个Unity检查不到，还有Lua，Lua是自己管理的。\nUnity Native Memory管理 Allocator与memory lable，Unity重载了几乎所有的内存分配符，比如alloc或者new。所以每个申请内存的操作都需要一个额外的\u0026quot;memory lable\u0026quot;的参数。标记着申请的内存应该放到哪一块内存池里面。 Allocator会根据memory lable分配到对应的池，每个池单独跟踪。 不明白（?_?）\n最佳实践 Scene C++引擎，所有实体都会反应在C++里面。不会反应在托管堆。 我们构建一个GO的时候，底层会建立一个到多个的GO来存储这个GO的信息，所以场景中存在多个GO的时候，Native内存就会显著上升。 很多UnityNative内存大量生成的时候，去检查Scene，经常就是这个问题。\nAudio DSP buffer，是可以设置几档位的，是声音的缓冲。 填充太大了，声音大小没那么大，就会延迟。 如果太小了，会经常向CPU发请求，导致CPU压力上升。\nForceToMono 音效师为了声音效果，将声音设置为双通道，但很多游戏音效实际是单声道也没有任何影响的（比如UI音效）。意味着一个1m的声音变成了2m，不仅影响包体还影响内存。 强制单声道。\nFormat 不同平台会有不同的Format支持，比如ios一般会推荐MP3,安卓hrbrs？这是什么？猜测是Vorbis（Ogg，Mkv）。 对于MP3，ios是有硬件支持的，速度会更好（Android没有）\nCompression Format 音频在游戏中是压缩的还是怎么样。\nCode Size 模板泛型乱用会导致影响打包速度以及Code Size，比如一个模板函数有4、5个泛型参数，结果导出一个Cpp 25m。 所有Class和template，最后都会展开，如果你一直排列组合，那么最后就会得到所有的排列组合，不重复。代码是一样的，但是类型不一样。IL2CPP就会给你展开。\nAssetBundle TypeTree 当前版本用到了哪些变量和对应数据类型，反序列化就根据TypeTree记录的内容。 没有就用默认值序列化。Build AssetBundle，当你确认同一个版本的Unity版本打出来的时候，TypeTree完全可以关掉，内存减少，包大小减少，build和运行时会变快。 每次序列化的时候，如果发现需要TypeTree序列化的时候，要序列化两次，先序列化TypeTree再序列化本体。\nLz4 Unity主推，效率快，压缩比率比Lzma差30%，速度快10倍左右。\nLzma 基本不用，解压和读取速度都慢，而且会占用大量内存，它不是用什么解压，而是全解压。chunkbase。Lzma不基于ChunkBase（那Lz4呢？），基于ChunkBase的访问旧的资源可以引用缓存减少内存消耗。\nSize \u0026amp; count 一个Ab包多大。 AB包基本都分两部分，头文件和实际文件。如果你每个资源都打一个包，那你就多了很多没用的头文件了。 官方推荐1m-2m一个AssetBundle，现在5g网络好很多就可以放宽考虑。\nResources文件夹 这个文件夹在打包的时候会生成一个R-B Tree，红黑树，帮助resources检索资源，如果Resources文件夹很大，你得RBTree就很大，会持续存在内存之中，从App打开就加载，这个红黑树没加载完游戏不会启动。 基本只在Debug的时候用。\nTexture upload buffer 填满多大向GPU发送push一次\nr/w: read / write Texture没必要就不需要开。 正常流程Texture，读进内存，解析完了，放到uploadbuffer上传了就会从内存delete掉。 你开了r/w就不会卸载了，就在你显存和内存都有一份。\nMipMaps UI没必要开。\nMesh r/w 同上\ncompression 有些版本开了不如不开，这个需要自己注意。\nAssets Unity Managed Memory Unity托管内存\nVM内存池 Mono虚拟机的内存池\nVM会返还内存给OS吗？ 会\n返还条件 当一个block连续6次GC没有被访问到，才会返还给系统，这种情况基本看不到，尤其是MonoRuntime的时候，ILRuntime可能稍微还会多一点机会。\nGC机制 GC不会把内存返还给系统 GC是一种机制，而这种机制有很多种不同的具体实现。 Untiy在用的叫Boehm-Demers-Weiser：相位裂缝\nUnity在用的Boehm是不分代的，有些GC会划分大中小块，还有不常用块，Unity没有，纯堆一起（快），而且它是非压缩式的GC，不会对内存进行重新调整位置。\n下一代GC Incremental GC（渐进式GC） 解决的是主线程卡顿的问题，现在的GC会暂停主线程，遍历所有的GC Memory，决定多少被GC掉。 IGC分帧做了，比如分成10帧去做，总体时间没变，但是可以改善卡顿情况。\nSGen或者升级Boehm SGen很先进，分代的。策略速度快\nIL2CPP Unity重新写的，升级版的Boehm\nGC机制考量 Throughput（回收能力） 一次回收回收多少内存\nPauseTimes（暂停时长） 进行内存回收的时候对主线程的影响多大\nFragmentation（碎片化） 回收内存之后，会对整体内存池碎片化贡献量\nMutatorOverhead（额外消耗） 统计，标记之类的消耗\nScalability（可拓展性） 扩展到多核多线程会不会有bug\nProtability（可移植性） 不同平台是否可以使用\n内存碎片化 就是因为不会挤掉间隔，间隔不够大就无法分配了。 这就被严重碎片化了。 如果进行高密度内存加载操作，先加载大内存，再加载小内存。 这部分内存不算内存泄漏，这叫Zombie Memory，无用内存，没有释放。它没有丢失一直都在，但是你也不用，它就占着这个位置。\n最佳实践 Don\u0026rsquo;t Null it，but Destroy it（用Destroy而不是设null） Class VS Struct看雨松 Pool In Pool高频使用的小部件，自己创建内存池，自己重用 Closures and anonymous methods（闭包和匿名函数） 所有的匿名和闭包最后会被IL生成翻译全都是new一个class，实际是一个class 里面所有函数和变量，里面所有new的东西都要占内存。\nCoroutines协程，只要没释放掉，所用的内存会一直存在，所有的变量。局部变量也是。用就生成，不用就去除掉。协程不是线程\nConfigurations（配置表）\nSingleton慎用，C++年代就是万恶资源，扔进去就不管，全在内存里。\nSetActive有GC，SetActive实际上会干很多工作，可以看源代码，有很多初始化的工作，比如子UI的递归情况。当你UISetActive很卡的时候，可以试试把UI放到屏幕外，这样就没有SetActive了。\nUnity内使用TPL，跟协程比起来需要注意的地方。 IO返回倒是可以用异步做，但是协程会轮询。如果轮询没什么消耗没关系，有问题就异步。\nUnity基本已经停止mono的支持了，以后会转ilruntime，\n","date":"2024-04-21T00:00:00Z","permalink":"http://localhost:1313/2024/unity%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/","title":"Unity内存管理"},{"content":"游戏对象以及其使用到的Network组件 NetworkManager 1 NetworkManagerHUD2\n[Telepathy Transport](#Telepathy Transport)\nNetworkManager\nSpawn(GameObject)3 NetworkStartPosition\nUI-Canvas(GameObject)4 TankGameManager(Script)\nTank(Perfab-GameObject)5 NetWorkIdentity\nNetworkTransform\nTank(Script)\n各组件以及脚本的用处 NetworkManager\n游戏状态管理 生成管理 场景管理 调试信息 自定义个性化 NetWorkManager是联机的核心组件，可以通过Inspector界面调整具体参数。\n每个Scene只能有一个NetworkManager，多余的会自动删除。由于具有NetworkIdentity组件的对象在加载场景的时候会自动禁用，所以NetworkManager不能放在游戏对象（会有操作）上。\nNetworkManager可以通过派生来根据项目实际需求来修改，自定义化，但如果项目不大，还是保持原样效率会更高。\nTelepathy Transport 在给游戏对象添加NetworkManager的时候会自动加上Telepathy Transport组件。这是一个管理数据传输的组件，如果有需要可以使用自己已有的，Inspector上的NetworkManager-NetworkInfo-Transport上切换即可。\n游戏状态管理 NetworkManager有三种运行模式-分别是：Server（仅服务器），Host（同时作为服务器和客户端），Client（仅客户端）。\n如果使用NetworkManagerHUD2则可直接在游戏运行时选择运行模式，自己调用为最优（一般来说）。\n调用的方法：\nNetworkManager.StartClient();\nNetworkManager.StartServer();\nNetworkManager.StartHost();\n如果脚本没有提前建立存放NetworkManager引用位6的话,只需要直接调用单例7就好。\n以Client模式开启前最好改变一下这个属性：NetworkManager.networkAddress\n也就是IP地址，同一台电脑上测试只需要填写localhost即可，但基本上用的时候肯定不是同一设备，所以可以增加一项功能：开启主机端，会在游戏内展示本机IP。\nC#获取自机IP的语句：\npublic string GetLocalIp()\r{\r///获取本地的IP地址\rstring IP = string.Empty;\rforeach (IPAddress _IPAddress in Dns.GetHostEntry(Dns.GetHostName()).AddressList)\r{\rif (_IPAddress.AddressFamily.ToString() == \u0026quot;InterNetwork\u0026quot;)\r{\rAddressIP = _IPAddress.ToString();\r}\r}\rreturn AddressIP;\r}\r我的做法是弹出输入框让玩家输入主机端玩家提供的IP，玩家多一步操作。\n流程基本就是：服务端/主机端开启，客户端同一网络下输入IP进入（非局域网联机尚未尝试）\n生成管理 NetworkManager具有管理对象生成的功能（动态生成）。\n如果要自主操作全局玩家的生成，则需要了解NetworkConnection相关知识（当前尚不讨论这一点）\nSpawn Info窗口管理着相关信息：\nPlayerPrefab：玩家的预制体（需要有NetworkIdentity）\nAutoCreatePlayer:bool（一般为开启，除非需要自主生成）\nPlayerSpawnMethod:两个属性：\nA：Random：场景上每一个具有NetworkStartPosition的对象随机成为生成点 B：RoundRobin：从Hierarchy从上往下每一个具有NetworkStartPosition组件的对象轮流作为生成点 Rigistered Spawnable Perfabs:\n这是一个列表，存放一些非玩家的需要动态生成的物体，比如子弹，金币奖励等。注意：这些物体同样需要NetworkIdentity组件\nNetworkStartPostition 在这里就要提到NetworkStartPosition，加入这个组件的物体将成为生成点。\nNetworkManager会调用GetStartPostiton()来获取Transform组件。\n场景管理 NetworkManager内置联机场景管理功能，一般而言只有两个槽位\nOffline Scene\nOnline Scene\n也就是一个离线场景和一个线上场景。\n启动服务器（Server）或者主机端（Host）的时候会直接加载Online Scene，同时客户端连接后也会加载至Online Scene。\nOffline Scene也直白：客户端和服务端断开连接的时候加载的场景。\n如需要在游戏中切换场景的话，则需要调用ServerChangeScene函数，让当前所有连接的客户端切换至新的Scene。需要切换的场景需要把名字加载进networkSceneName。\n但需要注意：以及开始运行的NetworkManager就别再调用StartHost或者StartClient等的操作了，不然可能会引起奇怪的事情。\n特别是NetworkManager会自动切换线上线下场景，所以NetworkManager在场景之间也要保持不变，不然会掉线。尽可能改设置而不是直接整个NetworkManager改变。\nTankGameManager(Script)\n这个组件（脚本）是起到类似GM的作用，也就是游戏的管理。\n在这个例子里，玩家的数据是直接由玩家本体存储，也就是Tank脚本内存储以及同步。\n这个GM主要的作用是：更新UI，判定游戏输赢（以UI展示，没有实际用于服务器的判定GM）。\n在这里简单讲一下Mirror实际的效果：\nA,B两个玩家，我们设A为Host，也就是主机端，实际A操作的依然是客户端，只是网络上它也在做服务器做的事而已，B作为客户端加入同一个场景。\n就好像玩遥控车一样，遥控车是玩家预制体，遥控是UI。但是我们彼此在各自的视野里只看得见对手的车，其他都看不见。\n换个角度，我在一个赛道（Scene）里玩遥控车（有UI），还有其他自己会走动的遥控车（无UI），他们在我的Scene只有预制体，只不过他们受“遥控”而已。\n实测之后这个GM有漏洞，漏洞在于假设出现这种在玩家预制体内的__同步数据__:\n[SyncVar]\rpublic int PlayerHP;\r这些数据都需要由Server端改变，也就是发送指令，由服务端接受指令并执行，客户端是无权修改的。\n如果是Unity内运行，主机端也只能修改自己的数据，对其他加入的玩家的数据的修改是无效的。\nNetworkIdentity\n一个网络认证组件，相当于进入游戏的通行证，有了它，Mirror管理的时候才可以把各个物体区分开来。\n只有一个选项可以勾选，\nServerOnly\n如果勾选了的话这个物体只能在服务端生成，客户端是不会生成的，例如局域网游戏的裁判等，这种游戏对象一般来讲客户端只负责接受数据和处理前端，判断输赢则仅从服务端即可，就好像一个隐形的旁观者。（具体没操作过这个Serveronly，可以尝试一下）\nNetworkTransform\n这是一个用于同步位置的组件，可以同步对象的位置移动缩放。\n直白点就是同步Transform的数据\n这里有一个很坑的地方：如果你没有勾选Client Authority这个选项，客户端的位置是不会同步到服务端的，也就是客户端做任何事实际上都是没有效果的。\nClient Authority客户端移动权限。\nNetworkTransform组件还可以修改灵敏度Sensitivity，只有一帧内变化超过阈值才会同步。\nSyncMode则可以修改同步的对象，是告诉所有人（Observers观察者），还是只是服务器（Owner私有）\nSyncInterval则是同步频率，以秒为单位，0-2取值。\n如果有子对象需要跟着移动，则需要在父对象上添加Network Transform Child，并将Target设置为子物体。\nTank(Script)\n这是例子中的玩家脚本。在需要网络上使用的对象，其脚本应该继承NetworkBehaviour，使用起来跟MonoBehaviour相差无几。\n这里就存在三种特性：[SyncVar] , [Command] , [ClientRpc]\n[SyncVar]：同步数据。\n刚刚提到过，有这种特性的数据的修改只能从服务端修改，客户端是没有权限修改的，只能读取。\n而怎么修改呢？则要通过有[ServerCallBack],[Server]的方法。\n有这些特性的方法都只会在服务器端执行。\n比如子弹中的碰撞，OnTriggerEnter（），在前面加一个[ServerCallBack]的特性，这个判定则在服务端判定，相当于告诉服务器，要是撞到了就调用这个方法。\n[Server]的方法则直接在服务器执行。\n这些是禁止客户端调用的，那如果客户端发射子弹呢？则需要用到[Command]的特性，有这个特性的方法会告诉服务器我要做这个方法，然后服务器就会帮你做。举个例子：\n我要杀A，我告诉B（服务端）我要用手枪杀A，B就接受我的手枪把A干掉，如果我还要B把手枪还我，则还我的这个方法需要有[ClientRpc]的特性，相当于这是客户端接受服务端的反馈并且执行。\n所以杀人要用[Command]，杀完人手枪还我要加[ClientRpc]。\n联机状态管理组件\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nNetworkManager的GUI版，在场景运行时实时展示的UI，可以直接改变NetworkManager的属性。\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n复活点\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nUI界面\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n玩家预制体-坦克\u0026#160;\u0026#x21a9;\u0026#xfe0e;\npublic NetworkManager networkManager;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n例子:NetworkManager.singleton.StartHost();\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"2022-10-18T00:00:00Z","permalink":"http://localhost:1313/2022/unity-mirror%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-tank/","title":"Unity-Mirror学习笔记-Tank"},{"content":"出现的问题 如同其他游戏一般，想要在A场景往C场景移动的时候，冒出来一个作为加载场景的B，实现A-\u0026gt;B-\u0026gt;C的效果，但是实测的时候会出现问题，有但不限于：\nA、如果C场景太少内容，B没机会出来就直接加载C了，即使已经禁止了allowSceneActivation依然会加载。\nB、异步进度一直为零。\n分析问题 Unity单次载入场景只能为一个，如果顺序错误似乎会造成程序认为在同时加载B和C（不确定的原因）。\n加载B的途中，即使B的内容很少可以瞬间加载，但是脚本动作更快，在B加载完之前C就加载完了，跳过了这一步的同时也造成即使allowSceneActivation为False也可以载入。\n问题解决方案 在输入载入作为Loading场景的B后，把后面的代码延迟一小会，目前测试延迟0.1s也可以，没测试过延迟一帧，但是如果出现问题的确是因为第二个原因，那么延迟一帧不一定稳定，延迟0.1s既不影响体验也可以保证稳定性。\n一下是代码内容：\nIEnumerator LoadScene_IEnumerator()\r{\rtime = 0;\rSceneManager.LoadScene(\u0026quot;Load\u0026quot;);\ryield return new WaitForSecondsRealtime(0.1f);\rasyncOperation = null;\rasyncOperation = SceneManager.LoadSceneAsync(SceneName);\rasyncOperation.allowSceneActivation = false;\rDebug.Log(\u0026quot;Now Loading: \u0026quot;+ SceneName);\rwhile (!asyncOperation.isDone)\r{\r// Check if the load has finished\rif (asyncOperation.progress \u0026gt;= 0.9f)\r{\r//Wait to you press the space key to activate the Scene\rif (time \u0026gt;= LeastTimeNeedWait)\r{\rWaitToClick = true;\rif (Input.anyKey)\r{\rasyncOperation.allowSceneActivation = true;\rWaitToClick = false;\rasyncOperation = null;\rStopCoroutine(LoadScene_IEnumerator());\r}\r}\r}\ryield return null;\r}\r}\r注意：\n协程中的While请记得添加yield return，不然会导致Unity崩溃，不强行关闭内存占用会一直上升。\n曾经出现这个问题，疑惑了两三天，上网搜索无果只能不断尝试。\n愿能为出现这个问题的人提供帮助。\n","date":"2022-09-20T00:00:00Z","permalink":"http://localhost:1313/2022/unity-loadsceneasync%E5%87%BA%E7%8E%B0%E7%9A%84%E5%8D%8F%E7%A8%8B%E9%97%AE%E9%A2%98/","title":"Unity-LoadSceneAsync出现的协程问题"}]