[{"content":"https://www.bilibili.com/video/BV1aJ411t7N6/\nhttps://www.bilibili.com/read/cv3260881/ GC文章翻译（第三方）\n物理内存 CPU的内存读取其实很慢，每次都会访问CPU中的Shared Cache再去内存找，也就是核心自己的内存。 台式设备和移动设备内存架构差异大：没有独显，没有显卡，CPU板上面积更小，缓存级数更少，大小更小。 所以有时候Android的报错溢出不是内存，是显存爆炸了。\n虚拟内存 内存交换（放到硬盘上的内存）移动设备的IO也很慢，移动设备的内存交换性能也有消耗，硬盘读写寿命也更少。 iOS可以进行内存压缩，但是Android没有（） iOS能把不用的程序占用的内存可以先压缩，也是存在内存里面。\n内存寻址范围 32位和64位讲的是计算器运算位数而不是MCU位数，MemoryControlUnit。\nAndroid内存管理 Android基于Linux，4K一个Page，Page是最基本的内存单位 内存杀手 - Low Memory Killer\n4K Per page 回收和分配都是以page为单位 用户态和内核态区分。内核态内存，用户态是严格不许访问的。\nAKA Lmk - low memory killer 按照软件优先度杀软件，按理来说可以把Wifi功能都给你杀了。 App原地重启都有可能。壁纸都给你杀掉。然后你手机就重启了。\n内存指标 Resident Set Size（RSS） 当前APP调用的所有内存，RSS算上所有公共库的内存，也就是你的插件也算在你的APP的PSS。\nProportional Set Size（PSS） 如果公共库有其他APP用，那就是平均分到每个APP上。\nUnique Set Size（USS） USS是只有你自己用的，纯粹只有你自己申请的。\n例子：Procrank 可以列出所有内存使用信息。 如果PSS很高，USS很低，那就很可能你是被背锅了。一般平台用的是PSS检查。\nUnity内存管理 Unity是C++引擎，底层代码完全由C++所写，每一行。 通过Wrapper提供给用户API。所以所有API都是在[.Bindings]里面放的。 用户代码仍会转换为Cpp代码(il2cpp) VM仍然存在。\n用il2cpp之后，几乎没有纯正的C#在跑。有了VM跨平台会更加方便。\n按分配方式分为 NativeMemory和ManagedMemory，在Editor和Runtime是不同的。 不同不只是说，统计数据不一样，是分配方式都不一样。\nAsset在Runtime不加载不放进内存，在Editor会全部加载。（演讲者：巨型项目见过加载一礼拜的） 2019.3推出AssetPipeline2.0，会加载基础的，后面的拓展的才会加载，详细可以自己搜搜。\nUnity内存按照管理者可以分为：引擎管理内存、用户管理内存\n引擎内存 引擎自己调用请求用的，一般开发者不需要触碰。\n用户管理内存 用户写的寄的代码就会导致很容易爆炸，确切需要关心的。\nUnity检测不到的内存：用户分配的native内存，比如用户自己写的C++插件，这个Unity检查不到，还有Lua，Lua是自己管理的。\nUnity Native Memory管理 Allocator与memory lable，Unity重载了几乎所有的内存分配符，比如alloc或者new。所以每个申请内存的操作都需要一个额外的\u0026quot;memory lable\u0026quot;的参数。标记着申请的内存应该放到哪一块内存池里面。 Allocator会根据memory lable分配到对应的池，每个池单独跟踪。 不明白（?_?）\n最佳实践 Scene C++引擎，所有实体都会反应在C++里面。不会反应在托管堆。 我们构建一个GO的时候，底层会建立一个到多个的GO来存储这个GO的信息，所以场景中存在多个GO的时候，Native内存就会显著上升。 很多UnityNative内存大量生成的时候，去检查Scene，经常就是这个问题。\nAudio DSP buffer，是可以设置几档位的，是声音的缓冲。 填充太大了，声音大小没那么大，就会延迟。 如果太小了，会经常向CPU发请求，导致CPU压力上升。\nForceToMono 音效师为了声音效果，将声音设置为双通道，但很多游戏音效实际是单声道也没有任何影响的（比如UI音效）。意味着一个1m的声音变成了2m，不仅影响包体还影响内存。 强制单声道。\nFormat 不同平台会有不同的Format支持，比如ios一般会推荐MP3,安卓hrbrs？这是什么？猜测是Vorbis（Ogg，Mkv）。 对于MP3，ios是有硬件支持的，速度会更好（Android没有）\nCompression Format 音频在游戏中是压缩的还是怎么样。\nCode Size 模板泛型乱用会导致影响打包速度以及Code Size，比如一个模板函数有4、5个泛型参数，结果导出一个Cpp 25m。 所有Class和template，最后都会展开，如果你一直排列组合，那么最后就会得到所有的排列组合，不重复。代码是一样的，但是类型不一样。IL2CPP就会给你展开。\nAssetBundle TypeTree 当前版本用到了哪些变量和对应数据类型，反序列化就根据TypeTree记录的内容。 没有就用默认值序列化。Build AssetBundle，当你确认同一个版本的Unity版本打出来的时候，TypeTree完全可以关掉，内存减少，包大小减少，build和运行时会变快。 每次序列化的时候，如果发现需要TypeTree序列化的时候，要序列化两次，先序列化TypeTree再序列化本体。\nLz4 Unity主推，效率快，压缩比率比Lzma差30%，速度快10倍左右。\nLzma 基本不用，解压和读取速度都慢，而且会占用大量内存，它不是用什么解压，而是全解压。chunkbase。Lzma不基于ChunkBase（那Lz4呢？），基于ChunkBase的访问旧的资源可以引用缓存减少内存消耗。\nSize \u0026amp; count 一个Ab包多大。 AB包基本都分两部分，头文件和实际文件。如果你每个资源都打一个包，那你就多了很多没用的头文件了。 官方推荐1m-2m一个AssetBundle，现在5g网络好很多就可以放宽考虑。\nResources文件夹 这个文件夹在打包的时候会生成一个R-B Tree，红黑树，帮助resources检索资源，如果Resources文件夹很大，你得RBTree就很大，会持续存在内存之中，从App打开就加载，这个红黑树没加载完游戏不会启动。 基本只在Debug的时候用。\nTexture upload buffer 填满多大向GPU发送push一次\nr/w: read / write Texture没必要就不需要开。 正常流程Texture，读进内存，解析完了，放到uploadbuffer上传了就会从内存delete掉。 你开了r/w就不会卸载了，就在你显存和内存都有一份。\nMipMaps UI没必要开。\nMesh r/w 同上\ncompression 有些版本开了不如不开，这个需要自己注意。\nAssets Unity Managed Memory Unity托管内存\nVM内存池 Mono虚拟机的内存池\nVM会返还内存给OS吗？ 会\n返还条件 当一个block连续6次GC没有被访问到，才会返还给系统，这种情况基本看不到，尤其是MonoRuntime的时候，ILRuntime可能稍微还会多一点机会。\nGC机制 GC不会把内存返还给系统 GC是一种机制，而这种机制有很多种不同的具体实现。 Untiy在用的叫Boehm-Demers-Weiser：相位裂缝\nUnity在用的Boehm是不分代的，有些GC会划分大中小块，还有不常用块，Unity没有，纯堆一起（快），而且它是非压缩式的GC，不会对内存进行重新调整位置。\n下一代GC Incremental GC（渐进式GC） 解决的是主线程卡顿的问题，现在的GC会暂停主线程，遍历所有的GC Memory，决定多少被GC掉。 IGC分帧做了，比如分成10帧去做，总体时间没变，但是可以改善卡顿情况。\nSGen或者升级Boehm SGen很先进，分代的。策略速度快\nIL2CPP Unity重新写的，升级版的Boehm\nGC机制考量 Throughput（回收能力） 一次回收回收多少内存\nPauseTimes（暂停时长） 进行内存回收的时候对主线程的影响多大\nFragmentation（碎片化） 回收内存之后，会对整体内存池碎片化贡献量\nMutatorOverhead（额外消耗） 统计，标记之类的消耗\nScalability（可拓展性） 扩展到多核多线程会不会有bug\nProtability（可移植性） 不同平台是否可以使用\n内存碎片化 就是因为不会挤掉间隔，间隔不够大就无法分配了。 这就被严重碎片化了。 如果进行高密度内存加载操作，先加载大内存，再加载小内存。 这部分内存不算内存泄漏，这叫Zombie Memory，无用内存，没有释放。它没有丢失一直都在，但是你也不用，它就占着这个位置。\n最佳实践 Don\u0026rsquo;t Null it，but Destroy it（用Destroy而不是设null） Class VS Struct看雨松 Pool In Pool高频使用的小部件，自己创建内存池，自己重用 Closures and anonymous methods（闭包和匿名函数） 所有的匿名和闭包最后会被IL生成翻译全都是new一个class，实际是一个class 里面所有函数和变量，里面所有new的东西都要占内存。\nCoroutines协程，只要没释放掉，所用的内存会一直存在，所有的变量。局部变量也是。用就生成，不用就去除掉。协程不是线程\nConfigurations（配置表）\nSingleton慎用，C++年代就是万恶资源，扔进去就不管，全在内存里。\nSetActive有GC，SetActive实际上会干很多工作，可以看源代码，有很多初始化的工作，比如子UI的递归情况。当你UISetActive很卡的时候，可以试试把UI放到屏幕外，这样就没有SetActive了。\nUnity内使用TPL，跟协程比起来需要注意的地方。 IO返回倒是可以用异步做，但是协程会轮询。如果轮询没什么消耗没关系，有问题就异步。\nUnity基本已经停止mono的支持了，以后会转ilruntime，\n","date":"2024-04-21T00:00:00Z","permalink":"http://localhost:1313/2024/unity%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/","title":"Unity内存管理"},{"content":"最好使用LTS进行开发。\n并非所有平台都完美支持所有Unity附带的功能，比如主机端不支持移动端的广告和分析功能。可能还违反服务协议。\n选择渲染管线，有些平台不支持HDRP，最好使用URP，因为它支持所有平台。\n对于多平台而言：平台特定的代码，质量设置，后期效果，着色器图形设置等，需要根据平台设置，或者使用SDK。 多查看文档，特别是SDK的。\n如果需要iOS平台则需要Mac。\n对于主机平台，需要向主机平台所属的厂商申请开发者套件。 了解你要发布的平台，你需要确定使用的硬件有什么限制。有些硬件的要求会严格(垃圾Switch机能？)硬件存储速度，Shader兼容等，CPU架构也有影响。手机则需要注重性能，发热等。 开发前就应该确认好。减少后期维护成本。\n当新设备性价比差，价格贵，断货时，旧设备的用户会维持在较高水平。\n抽象代码库！不同平台的对于某些功能的步骤或许相似，但是实践上会根据设备有较大的差异。有些平台或许还没有某个功能。\n错误使用API是主机平台上最常见的认证失败原因\n有些平台不支持Mono，主机平台要求使用IL2CPP，意味着只能用AOT，任何JIT反射，序列化都可能失效。\n主机平台用ResourcesAPI会大幅增加游戏启动时间。还可能导致认证失败。 PlayerPrefs也是，最好自己写写入读取实现。\n最好一开始就用Addressable，管理资产和内存。有些平台对DLC和补丁的大小也有要求。\n第三方库和插件不一定支持所有平台，因为有些开发者访问不了受到保密协议保护的平台。遇到问题才重写代码会大大延迟你得开发。\n就算短期内你可能只考虑开发PC和移动端，但是如果游戏火了，需要移植的时候，你还是需要处理多平台的问题。然后你就要大幅重写了。\n阅读目标硬件文档！ 这不仅影响性能优化，还影响你的认证要求。\nEditor下跟实际硬件跑是两回事，测试你的功能在目标平台是否可行。 你用champion主机开发Editor下114514帧，结果构建发布只有14帧，你就寄。定期测试你的游戏（实机），将重点放在最低性能的机子上测。 比如Unity还支持iOS12，就意味着iPhone 5S仍受支持。所以要买点旧设备来测试。 从旧设备测，然后建立一个基准，你就知道性能是否慢慢变差了，做性能分析（实机），做性能分析Pro，让所有机子都60FPS跑，\n不同平台对发布要求有不一样，你需要满足才能发布游戏，你需要开发前就处理。线程锁定，内存占用、随机崩溃死机啥的， 构建失败是最常见的，有些人都还没测过构建就发布了，当然过不了了。有些平台会有预认证功能会方便很多。\n即使是VR，也有PCVR，独立VR，主机VR等目标平台，有各种性能要求，你要确保流程避免卡顿，玩家才能玩的舒服。 不同VR的输入和追踪实现可能大相径庭。\n在开发初期就具备对目标平台的性能控制，能够让你在开发初期就对性能消耗有所控制，定期检查，初期就达成60FPS。\n提出问题 1、对于主机平台，不支持JIT。如果游戏是拥有代码热更功能的项目，是不是意味着需要根据导出的平台去处理程序集？这些平台是不是一点反射都用不了？\n答：我认为并不是一点反射都用不了，毕竟我现在负责的项目就有设计到Switch。项目中由于旧框架的设计目的，用了大量的反射去处理，没见到有这方面的影响。\n","date":"2024-04-21T00:00:00Z","permalink":"http://localhost:1313/2024/unity%E5%A4%9A%E5%B9%B3%E5%8F%B0%E5%BC%80%E5%8F%91%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/","title":"Unity多平台开发注意事项"},{"content":"围绕收集系统而言，想让玩家收集就需要激励他们。而从激励角度，有分外部激励和内部激励。\n外部激励 关卡 就是机制所需。比如你必须收集x个勾八才能开启下一关。\n强化 你收集3个电池就能获得能力上的升级。\n或者是新服装、新道具、新武器、新技能、新代币等等。\n有时候它跟你的角色强度挂钩，有时候又直接影响你通关的难度。\n场景 比如马里奥中，你收集齐全所有收集物后，不仅会解锁一个特殊的场景，还可以以路易吉角色重新游玩，并且是全新的体验。\n坏使用场景 比如古惑狼4，有些关卡对你拾取、通过次数等有限制，甚至要你收集齐所有箱子，但是每一关也摁藏箱子的同时还有一些场景是无法回头的。\n内部奖励 内在奖励的作用是让玩家出于自己的意愿想要完成的一些目标。\n收集这些东西意味着一段旅程，而这段旅程本身就是一种奖励。\n入门级别：在收集到的时候设置一个很酷的声音或者闪光特效。跳舞也行。\n因为这些手段可以让“收集”变得更加有趣，而令这个过程变得更令人满足。\n内在奖励关注的是过程。收集品只是最后的点睛之笔。移动冒险相关游戏就比较适用。\n但是大金刚64那套设计就比较顶尖了。一个地图5种收集物，5个角色只能拿自己能拿的，全收集就要5个角色打同一关5次。\n宝可梦图鉴还会引导你去全收集，告诉你有哪些你没有见过，大概出现的地方这样。\n或者可以有类似原神那个宝物罗盘，虽然它也是抄别人的。\n最好不要产生“大海捞针”的体验。\n参考信息 Bilibili: 【中英字幕】如何设计好的收集系统 | Design Doc 设计文档_哔哩哔哩bilibili\nYoutube: # Collectibles - How To Make Chores Fun In Games\n","date":"2023-06-14T00:00:00Z","permalink":"http://localhost:1313/2023/%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E5%A5%BD%E7%9A%84%E6%94%B6%E9%9B%86%E7%B3%BB%E7%BB%9F/","title":"如何设计好的收集系统"},{"content":"游戏对象以及其使用到的Network组件 NetworkManager 1 NetworkManagerHUD2\n[Telepathy Transport](#Telepathy Transport)\nNetworkManager\nSpawn(GameObject)3 NetworkStartPosition\nUI-Canvas(GameObject)4 TankGameManager(Script)\nTank(Perfab-GameObject)5 NetWorkIdentity\nNetworkTransform\nTank(Script)\n各组件以及脚本的用处 NetworkManager\n游戏状态管理 生成管理 场景管理 调试信息 自定义个性化 NetWorkManager是联机的核心组件，可以通过Inspector界面调整具体参数。\n每个Scene只能有一个NetworkManager，多余的会自动删除。由于具有NetworkIdentity组件的对象在加载场景的时候会自动禁用，所以NetworkManager不能放在游戏对象（会有操作）上。\nNetworkManager可以通过派生来根据项目实际需求来修改，自定义化，但如果项目不大，还是保持原样效率会更高。\nTelepathy Transport 在给游戏对象添加NetworkManager的时候会自动加上Telepathy Transport组件。这是一个管理数据传输的组件，如果有需要可以使用自己已有的，Inspector上的NetworkManager-NetworkInfo-Transport上切换即可。\n游戏状态管理 NetworkManager有三种运行模式-分别是：Server（仅服务器），Host（同时作为服务器和客户端），Client（仅客户端）。\n如果使用NetworkManagerHUD2则可直接在游戏运行时选择运行模式，自己调用为最优（一般来说）。\n调用的方法：\nNetworkManager.StartClient();\nNetworkManager.StartServer();\nNetworkManager.StartHost();\n如果脚本没有提前建立存放NetworkManager引用位6的话,只需要直接调用单例7就好。\n以Client模式开启前最好改变一下这个属性：NetworkManager.networkAddress\n也就是IP地址，同一台电脑上测试只需要填写localhost即可，但基本上用的时候肯定不是同一设备，所以可以增加一项功能：开启主机端，会在游戏内展示本机IP。\nC#获取自机IP的语句：\npublic string GetLocalIp()\r{\r///获取本地的IP地址\rstring IP = string.Empty;\rforeach (IPAddress _IPAddress in Dns.GetHostEntry(Dns.GetHostName()).AddressList)\r{\rif (_IPAddress.AddressFamily.ToString() == \u0026quot;InterNetwork\u0026quot;)\r{\rAddressIP = _IPAddress.ToString();\r}\r}\rreturn AddressIP;\r}\r我的做法是弹出输入框让玩家输入主机端玩家提供的IP，玩家多一步操作。\n流程基本就是：服务端/主机端开启，客户端同一网络下输入IP进入（非局域网联机尚未尝试）\n生成管理 NetworkManager具有管理对象生成的功能（动态生成）。\n如果要自主操作全局玩家的生成，则需要了解NetworkConnection相关知识（当前尚不讨论这一点）\nSpawn Info窗口管理着相关信息：\nPlayerPrefab：玩家的预制体（需要有NetworkIdentity）\nAutoCreatePlayer:bool（一般为开启，除非需要自主生成）\nPlayerSpawnMethod:两个属性：\nA：Random：场景上每一个具有NetworkStartPosition的对象随机成为生成点 B：RoundRobin：从Hierarchy从上往下每一个具有NetworkStartPosition组件的对象轮流作为生成点 Rigistered Spawnable Perfabs:\n这是一个列表，存放一些非玩家的需要动态生成的物体，比如子弹，金币奖励等。注意：这些物体同样需要NetworkIdentity组件\nNetworkStartPostition 在这里就要提到NetworkStartPosition，加入这个组件的物体将成为生成点。\nNetworkManager会调用GetStartPostiton()来获取Transform组件。\n场景管理 NetworkManager内置联机场景管理功能，一般而言只有两个槽位\nOffline Scene\nOnline Scene\n也就是一个离线场景和一个线上场景。\n启动服务器（Server）或者主机端（Host）的时候会直接加载Online Scene，同时客户端连接后也会加载至Online Scene。\nOffline Scene也直白：客户端和服务端断开连接的时候加载的场景。\n如需要在游戏中切换场景的话，则需要调用ServerChangeScene函数，让当前所有连接的客户端切换至新的Scene。需要切换的场景需要把名字加载进networkSceneName。\n但需要注意：以及开始运行的NetworkManager就别再调用StartHost或者StartClient等的操作了，不然可能会引起奇怪的事情。\n特别是NetworkManager会自动切换线上线下场景，所以NetworkManager在场景之间也要保持不变，不然会掉线。尽可能改设置而不是直接整个NetworkManager改变。\nTankGameManager(Script)\n这个组件（脚本）是起到类似GM的作用，也就是游戏的管理。\n在这个例子里，玩家的数据是直接由玩家本体存储，也就是Tank脚本内存储以及同步。\n这个GM主要的作用是：更新UI，判定游戏输赢（以UI展示，没有实际用于服务器的判定GM）。\n在这里简单讲一下Mirror实际的效果：\nA,B两个玩家，我们设A为Host，也就是主机端，实际A操作的依然是客户端，只是网络上它也在做服务器做的事而已，B作为客户端加入同一个场景。\n就好像玩遥控车一样，遥控车是玩家预制体，遥控是UI。但是我们彼此在各自的视野里只看得见对手的车，其他都看不见。\n换个角度，我在一个赛道（Scene）里玩遥控车（有UI），还有其他自己会走动的遥控车（无UI），他们在我的Scene只有预制体，只不过他们受“遥控”而已。\n实测之后这个GM有漏洞，漏洞在于假设出现这种在玩家预制体内的__同步数据__:\n[SyncVar]\rpublic int PlayerHP;\r这些数据都需要由Server端改变，也就是发送指令，由服务端接受指令并执行，客户端是无权修改的。\n如果是Unity内运行，主机端也只能修改自己的数据，对其他加入的玩家的数据的修改是无效的。\nNetworkIdentity\n一个网络认证组件，相当于进入游戏的通行证，有了它，Mirror管理的时候才可以把各个物体区分开来。\n只有一个选项可以勾选，\nServerOnly\n如果勾选了的话这个物体只能在服务端生成，客户端是不会生成的，例如局域网游戏的裁判等，这种游戏对象一般来讲客户端只负责接受数据和处理前端，判断输赢则仅从服务端即可，就好像一个隐形的旁观者。（具体没操作过这个Serveronly，可以尝试一下）\nNetworkTransform\n这是一个用于同步位置的组件，可以同步对象的位置移动缩放。\n直白点就是同步Transform的数据\n这里有一个很坑的地方：如果你没有勾选Client Authority这个选项，客户端的位置是不会同步到服务端的，也就是客户端做任何事实际上都是没有效果的。\nClient Authority客户端移动权限。\nNetworkTransform组件还可以修改灵敏度Sensitivity，只有一帧内变化超过阈值才会同步。\nSyncMode则可以修改同步的对象，是告诉所有人（Observers观察者），还是只是服务器（Owner私有）\nSyncInterval则是同步频率，以秒为单位，0-2取值。\n如果有子对象需要跟着移动，则需要在父对象上添加Network Transform Child，并将Target设置为子物体。\nTank(Script)\n这是例子中的玩家脚本。在需要网络上使用的对象，其脚本应该继承NetworkBehaviour，使用起来跟MonoBehaviour相差无几。\n这里就存在三种特性：[SyncVar] , [Command] , [ClientRpc]\n[SyncVar]：同步数据。\n刚刚提到过，有这种特性的数据的修改只能从服务端修改，客户端是没有权限修改的，只能读取。\n而怎么修改呢？则要通过有[ServerCallBack],[Server]的方法。\n有这些特性的方法都只会在服务器端执行。\n比如子弹中的碰撞，OnTriggerEnter（），在前面加一个[ServerCallBack]的特性，这个判定则在服务端判定，相当于告诉服务器，要是撞到了就调用这个方法。\n[Server]的方法则直接在服务器执行。\n这些是禁止客户端调用的，那如果客户端发射子弹呢？则需要用到[Command]的特性，有这个特性的方法会告诉服务器我要做这个方法，然后服务器就会帮你做。举个例子：\n我要杀A，我告诉B（服务端）我要用手枪杀A，B就接受我的手枪把A干掉，如果我还要B把手枪还我，则还我的这个方法需要有[ClientRpc]的特性，相当于这是客户端接受服务端的反馈并且执行。\n所以杀人要用[Command]，杀完人手枪还我要加[ClientRpc]。\n联机状态管理组件\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nNetworkManager的GUI版，在场景运行时实时展示的UI，可以直接改变NetworkManager的属性。\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n复活点\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nUI界面\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n玩家预制体-坦克\u0026#160;\u0026#x21a9;\u0026#xfe0e;\npublic NetworkManager networkManager;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n例子:NetworkManager.singleton.StartHost();\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"2022-10-18T00:00:00Z","permalink":"http://localhost:1313/2022/unity-mirror%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-tank/","title":"Unity-Mirror学习笔记-Tank"},{"content":"出现的问题 如同其他游戏一般，想要在A场景往C场景移动的时候，冒出来一个作为加载场景的B，实现A-\u0026gt;B-\u0026gt;C的效果，但是实测的时候会出现问题，有但不限于：\nA、如果C场景太少内容，B没机会出来就直接加载C了，即使已经禁止了allowSceneActivation依然会加载。\nB、异步进度一直为零。\n分析问题 Unity单次载入场景只能为一个，如果顺序错误似乎会造成程序认为在同时加载B和C（不确定的原因）。\n加载B的途中，即使B的内容很少可以瞬间加载，但是脚本动作更快，在B加载完之前C就加载完了，跳过了这一步的同时也造成即使allowSceneActivation为False也可以载入。\n问题解决方案 在输入载入作为Loading场景的B后，把后面的代码延迟一小会，目前测试延迟0.1s也可以，没测试过延迟一帧，但是如果出现问题的确是因为第二个原因，那么延迟一帧不一定稳定，延迟0.1s既不影响体验也可以保证稳定性。\n一下是代码内容：\nIEnumerator LoadScene_IEnumerator()\r{\rtime = 0;\rSceneManager.LoadScene(\u0026quot;Load\u0026quot;);\ryield return new WaitForSecondsRealtime(0.1f);\rasyncOperation = null;\rasyncOperation = SceneManager.LoadSceneAsync(SceneName);\rasyncOperation.allowSceneActivation = false;\rDebug.Log(\u0026quot;Now Loading: \u0026quot;+ SceneName);\rwhile (!asyncOperation.isDone)\r{\r// Check if the load has finished\rif (asyncOperation.progress \u0026gt;= 0.9f)\r{\r//Wait to you press the space key to activate the Scene\rif (time \u0026gt;= LeastTimeNeedWait)\r{\rWaitToClick = true;\rif (Input.anyKey)\r{\rasyncOperation.allowSceneActivation = true;\rWaitToClick = false;\rasyncOperation = null;\rStopCoroutine(LoadScene_IEnumerator());\r}\r}\r}\ryield return null;\r}\r}\r注意：\n协程中的While请记得添加yield return，不然会导致Unity崩溃，不强行关闭内存占用会一直上升。\n曾经出现这个问题，疑惑了两三天，上网搜索无果只能不断尝试。\n愿能为出现这个问题的人提供帮助。\n","date":"2022-09-20T00:00:00Z","permalink":"http://localhost:1313/2022/unity-loadsceneasync%E5%87%BA%E7%8E%B0%E7%9A%84%E5%8D%8F%E7%A8%8B%E9%97%AE%E9%A2%98/","title":"Unity-LoadSceneAsync出现的协程问题"}]